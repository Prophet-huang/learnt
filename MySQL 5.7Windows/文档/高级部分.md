# 高级部分

## **视图  view**

### 介绍

视图与表有很多相似的地方，视图也是由若干个字段以及若干条记录构成，视图也可以作为select语句的数据源。**视图中保存的仅仅是一条select语句，保存的是视图的定义，并没有保存真正的数据。**视图中的源数据都来自于数据库表，数据库表称为基本表或者基表，视图称为虚表。

**视图的作用**

1.使操作变得简单
2.避免数据冗余
3.增强数据安全性
4.提高数据的逻辑独立性 

### 语法

#### 曾

```mysql
create view `视图名` as 接查询语句;
```

**注意：在起视图名时要加前缀以防和表混淆。**

后面的跟的select语句，可以是普通的查询，也可以是连接查询，也可以是联合查询，子查询。

创建单表视图：基表只有一个。

创建多表视图：基表有多个。**注意:在建立多基表视图时，要注意，字段不能重复，也就是列不能重复.**

#### 查

表的查看方式都适用于视图

```mysql
select `要查的字段` from `视图名`;
```

解析：查视图看中的数据。

show tables; 查表名也能查到视图的名字。

**也可使用 show create view 和 desc  去查视图的结构.**



#### 改

视图本身是不可修改的，但是可以修改视图的来源

```mysql
alter view `视图名` as select `要查的字段名` from `基于的原表名`;
```

解析：更改视图中查询的字段。（说实在的不如删了，再建一个新视图）。



**如果想改视图名，把试图删了重新新建一个视图。**



##### 修改视图内容

视图是一个虚拟表，实际的数据来自于基本表，所以通过插入、修改和删除操作更新视图中的数据，实质上是在更新视图所引用的基本表的数据。因此在修改时，要满足基本表的数据定义。

然而某些视图是可更新的。也就是说，可以使用 UPDATE、DELETE 或 INSERT 等语句更新基本表的内容。对于可更新的视图，视图中的行和基本表的行之间必须具有一对一的关系。还有一些特定的其他结构，这些结构会使得视图不可更新。更具体地讲，如果视图包含以下结构中的任何一种，它就是不可更新的：

1.聚合函数 SUM()、MIN()、MAX()、COUNT() 等。

2.DISTINCT 关键字。

3.GROUP BY 子句。

4.HAVING 子句。

5.UNION 或 UNION ALL 运算符。

6.位于选择列表中的子查询。

7.FROM 子句中的不可更新视图或包含多个表。

8.WHERE 子句中的子查询，引用 FROM 子句中的表。

9.ALGORITHM 选项为 TEMPTABLE(使用临时表总会使视图成为不可更新的)的时候。

#### 删

```mysql
drop view `视图名`;
```



例：水果店表和水果店订单表

​	![](E:\learnt\MySQL 5.7Windows\Example diagram\+7.png)

创建视图并查询

![](E:\learnt\MySQL 5.7Windows\Example diagram\+8.png)



### 视图的算法

**介绍**

视图算法：系统对视图以及外部查询视图的select语句的一种解析方式。



**视图算法分成3种：**

 **Undefined:**未定义（默认）这不是一种算法，是一种推卸责任的算法， 告诉系统，视图没有定义算法，系统你自己看着办。

**Temp table:**临时表算法：先执行视图的select语句，然后在执行外部查询Select语句。

**Merge:**合并算法，系统在执行select语句之前，会对视图的select和外部查询视图的select语句进行合并，然后执行。



**算法的指定**
在创建视图的时候指定算法语法如下

```mysql
create  algorithm = 要改的算法 view `视图名` as select 接查询语句;
```



**算法选择**

如果视图的select语句中包含一个查询子句（order by,limit）,而且很可能该 关键字 执行顺序 比外部查询语句 关键字 靠后 一定要使用使用 temp table 算法，其他情况下不用指定，默认即可。



------



## **事务 transaction**

 事务主要用于处理操作量大，复杂度高的数据

**注意：只有使用了 Innodb 数据库引擎的数据库或表才支持事务**。



### ACID

原子性（**A**tomicity，或称不可分割性）、一致性（**C**onsistency）、隔离性（**I**solation，又称独立性）、持久性（**D**urability）。

1.**原子性：**一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

2.**一致性：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。

3.**隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。

4.**持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。





### 事务的操作

#### 事务的开启与提交（有两种方法）

**在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。**

**因此要显式地开启一个事务须使用命令 BEGIN 或 START TRANSACTION**

**或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。**



##### 1.用  BEGIN,  ROLLBACK,  COMMIT 来实现

开启事务

```mysql
begin; 
```

 或者

```mysql
start transaction;
```

解析：使用事务时开启事务,以上两条均可开启。



提交事务

```mysql
commit;
```

或者

```mysql
commit work;
```

解析：当完成要编辑的命令后提交，随后MySQL将会执行编辑的命令，以上两条均可提交。



##### 2.直接用 SET 来改变 MySQL 的自动提交模式

禁止自动提交

```mysql
set autocommit=0;
```



开启自动提交

```mysql
set autocommit=1;
```



#### 事务中设置储存点

savepoint 是在数据库事务处理中实现“子事务”（subtransaction），也称为嵌套事务的方法。

作用类似游戏的存档点，当我们在事务中写完几条命令并确认无误后可设置一个储存点，当接下来写的命令不需要了或错误时，可回滚到设置储存点时的命令状态。

建立储存点

```mysql
savepoint `储存点的名字`
```



回滚

```mysql
rollback to `储存点名字`
```



删除储存点

```mysql
release savepoint `储存点名名字`
```

**事务中可创建多个储存点**



### 扩充

#### 关于**事务回滚**后   自增的ID仍然**增加**   的问题以及解决办法

##### 问题

因为 innodb 的 auto_increment 的计数器记录的当前值是保存在内存中的，并不是存在于磁盘上，当MySQL server处于运行的时候，这个计数值只会随着 insert 的改动而增长，不会随着 delete 而减少。而当 MySQL server 启动时，当我们需要去查询auto_increment计数值时，MySQL便会自动执行：

```mysql
SELECT MAX(id) FROM `表名` FOR UPDATE;
```

语句来获得当auto_increment列的最大值，然后将这个值放到auto_increment计数器中。所以就算 Rollback MySQL 的 auto_increment 计数器也不会作负运算。



##### 解决办法

```mysql
insert into `要插入数据的表名` select (ifnull(max(id),0)+1),'要插入的数据' from `和前面一模一样表名`;
```

插入数据时不能丢项少项，建议先查清楚在添加数据。

解析：

1.由于 auto_increment 的问题我们 insert into 插入数据的方法不可行就要剑走偏锋，我们用到**查出表的全部数据并插入新表**（基本命令及关键字文档中提到过）这个办法，的变体。

2.但是我们要查出对应的的字段并且插入到表中，这就使得我们插入的字段属性要符合我们插入的表。这就是为什么from后要写 和前面一模一样表名。

3.id 这里 ifnull(,) 这个函数，我们自己计算id的最大值，不使用 auto_increment 的最大值 ，然后 +1，得出我们想要的 id。

![](E:\learnt\MySQL 5.7Windows\Example diagram\+9.png)

**备注：使用 delete 删除的数据的表该方法也适用。**





------

## **索引 index**

MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。

创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。

索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。

**种类**：单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。

**缺点：**虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行 增删改。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。建立索引会占用磁盘空间的索引文件。



### 索引的操作

在使用索引中又有 **普通索引** **主键索引**  **唯一键索引** 

操作索引可从三种命令方向入手 

1.**直接创建索引**（create(创建) / drop(删除)）

2.**修改表的结构** （alter table add(添加)/drop(删除)）

3.**在创建表的时候直接添加**（create table）

**注意：当创建索引的字段如果是BLOB和TEXT类型，必须指定 length。**



#### 主键索引

MySQL主键不需要建立索引，主键具备索引的功能；当创建或设置主键的时候，MySQL会自动添加一个与主键对应的唯一索引，不需要再做额外的添加。数据库管理系统对于主键会自动生成唯一索引，但又有不可重复的属性，所以主键是一个特殊的索引。



#### 普通索引

这是最基本的索引，它没有任何限制。它有以下几种创建方式：

```MySQL
create index `索引的名字` on `创建索引字段来自的 表名` (`要创建索引字段`(字符宽度),可多个变成组合索引);
```



```mysql
alter table `表名` add index `索引的名字` (`要创建索引字段`(字符宽度),可多个变成组合索引);
```



```mysql
CREATE TABLE mytable(  
 
ID INT NOT NULL,   
 
username VARCHAR(16) NOT NULL,  
 
INDEX `索引的名字` (`要创建索引字段`(字符宽度),可多个变成组合索引)  
 
);  
```





删除索引

```mysql
drop index `索引的名字` on `索引所在的表名`;
```



```mysql
alter table `索引所在的表名` drop index `索引的名字`
```



#### 唯一键索引

它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：

```mysql
create unique index `索引的名字` on `创建索引字段来自 表的名` (`要创建索引字段`(字符宽度),可多个变成组合索引);
```



```mysql
alter table `表名` add unique `索引的名字` (`要创建索引字段`(字符宽度),可多个变成组合索引);
```



```mysql
CREATE TABLE mytable(  
 
ID INT NOT NULL,   
 
username VARCHAR(16) NOT NULL,  
 
unique `索引的名字` (`要创建索引字段`(字符宽度),可多个变成组合索引)  
 
);  
```



删除同主键索引



### 显示索引信息

使用 SHOW INDEX 命令来列出表中的相关的索引信息。可以通过添加 \G 来格式化输出信息。

```mysql
show index from `表名`/G;
```





------



## **存储过程(Procedure）**

开发人员很难用到，大部分是 DBI 使用

存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。（MySQL中的函数）

简单说就是我们将许多 sql 命令写在一起，起个名字并存起来，在我们需要的时候拿出来直接调用。

优点

存储过程可封装，并隐藏复杂的商业逻辑。

存储过程可以回传值，并可以接受参数。

存储过程无法使用 SELECT 指令来运行，因为它是子程序，与查看表，数据表或用户定义函数不同。

存储过程可以用在数据检验，强制实行商业逻辑等。



缺点

存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程。

存储过程的性能调校与撰写，受限于各种数据库系统。



### 简单的创建存储过程

声明语句结束符，可以自定义 （delimiter）

因为我们要写很多条命令，并且我们不需要它立即执行，但是当我们使用分号的时候客户端就发送到服务器执行了，所以我们需要更改结束符。

```mysql
delimiter $$ 
或
delimiter //
```



书写过程

```mysql
create procedure `名子`(参数)
begin
`要写命令`
end$$或//
```



写完后别忘把结束符改回

```MySQL
delimiter ;
```



调用

```MySQL
call `名字`(参数);
```



删除

```mysql
drop procedure `名字`;
```



查

```MySQL
show create procedure `名字`;
```



### 扩展

<img src="E:\learnt\MySQL 5.7Windows\Example diagram\68.png"  />





------



## **函数**

https://www.runoob.com/mysql/mysql-functions.html









