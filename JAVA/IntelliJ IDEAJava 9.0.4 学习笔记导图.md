# 	IntelliJ IDEAJava 9.0.4 学习笔记导图

笔记以 idea 中创建项目的形式书写，该文档类似一个目录。

JVM + 核心类库 = JRE

JRE + java开发工具（javac.exe/jar.exe) = JDK

# 该文件包含 Java 最基础的语法

## 文件名： JavaBasicGrammar

#### 循环： 

while	do while	for	for嵌套	for each增强循环	switch	

#### 判断：

if else

#### String类：

String类简单字符串

.length()	方法介绍

String在数组中的应用：char 数组转换 String 字符串	创建 String 类型的数组（一维和多维）

import java.util.Arrays;   Arrays类（导包）中的方法，输出多维数组和一维数组。

#### Scanner的介绍：

import java.util.Scanner

Java 方法 Math.max()介绍

#### 三元运算符 ：

条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。

```java
variable x = (expression) ? value if true : value if false
```

#### 方法

**重载 ：方法名相同，方法参数的类型和个数不同。**

#### 传参注意事项：

方法传递数组

引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）,解决该问题可以使用深拷贝，内容不变地址改变。



------

# 该文件包含 Java oop 面向对象

面向过程POP：

- 把要解决的问题梳理出来，**线性顺序**的去解决问题，适用于解决单个对象问题（因为每个人都有自己独特的问题）。
- 集体服务于个人。
- 普遍人认为集体是为个人而存在的，而且集体的福利和力量的发挥是为了个人的利益的。

面向对象OOP：

- 把要解决的问题全部汇总，**解决共性问题**，特性问题单独解决，适用于解决多个对象的问题。
- 个人服务于集体。
- 毛认为个人存在于集体之中，并为集体而存在，而 且个人是在集体中才能获得幸福和才华的发挥。



OOP三大特性：封装	继承	多态



## 文件名：dogManagerOOPOne

通过记录狗状态来介绍面向对象

属性(类当中的变量和方法的总称)：属性是类的重要组成部分

成员变量（属性中的变量）	行为(属性中的方法)	

实例（根据所需属性，  引用的类， 的现实体现）	

对象(根据所需属性，引用的类, 的抽象说法)

你可以说一个实例是一个对象，但你不能说一个对象是一个实例。因为定义对象时只是把自身的规则和逻辑定义好，实例可以通过输入不同的数据使得自己和其他实例不同。

创建实例	调用属性

空指针介绍

## 文件名：dogManagerOOPTwo

public	private

#### OOP的封装

封装的思想

to String()	方法

## 文件名：dogManagerOOPThree

构造方法：写构造方法不需要返回值，不是空返回值因此是没有类型的，通常情况下需要一个无参数的构造，来满足初始化时不填参数。

构造方法的使用：初始化

使用构造方法后封装失效的问题

垃圾回收的问题

## 文件名：aboutStaticOOPUpFour

static（静态的修饰词）介绍：静态属性基于类。

静态变量

静态方法

静态代码块：和类一起完成初始化，只加载一次。

单例设计模式 ：再外部只能调用该类内部事先创建好的对象，不能在外部创建新的该类对象。

## 文件名：animalManagerOOPDownOne	

#### 继承 extends:

构造方法不能直接被子类继承，如果强行继承可用super。

多层继承

覆写/重写：

- 继承父类的方法，虽然方法名没变，但是子类需要根据子类的实际需求作出革新。

- Override和Overload不同的是，如果方法签名不同，就是Overload，Overload方法是一个新方法；如果方法签名相同，并且返回值也相同，就是Override。

   注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。

super：在子类中虽然重写了但还要用父类的属性，这时用 super 来修饰该属性。

final：可修饰：类、方法、常量。类不可继承，方法可继承但不能重写，常量可继承但不能修改。

## 文件名：animalManagerOOPDownTwo

Abstract 修饰抽象

抽象类：无法实例对象（没法new 对象）

抽象方法：没有方法体，被继承后必须重写

## 文件名：humanOOPDownThree

### 接口：

- 一个类可实现多个接口，接口中的属性：行为都是抽象方法，公共的静态常量。接口之间可继承。

- 接口是对动作的抽象，而抽象类是对根源(具体的事物)的抽象。

### 匿名内部类：

- 本质是一个继承或实现，类或接口，的子类的一个实例对象，只不过这个对象是匿名的。
- 场景：常用于该方法只会被调用当下这一次

## 文件名：huaMuLanOOPDownFour

### 多态：

同一个行为具有多个不同表现形式或形态的能力。

#### 多态存在的三个必要条件：

* 继承
* 重写
* 创建对象时父类 new 子类{有逼格的说法是：父类引用指向子类对象}没有向上的子类对象无法实现向下



- 向上转型：子类引用的对象转换为父类类型称为向上转型。通俗地说就是是将子类对象转为父类对象。此处父类对象可以是接口。转型后，只能使用父类的属性（子类自己的特性用不了），如果父类是接口使用的还是子类的属性(接口中的行为没方法体)。父类 名=new子类对象
- 向下转型：是建立再向上转型的基础上，父类引用的对象转换为子类类型称为向下转型。（需要强转）子类 名 =（强转子类）向上转型的对象名 

------

# 该文件包含 Java API 和进阶功能（不包含新特性）

object 是所有类的父类

## 文件名：javaApiOne

### scanner类：

一个简单的文本扫描器，可以使用正则表达式解析原始类型和字符串。 

------



### number：是抽象类（abstract），所有包装类的父类。

包装类优势：面向对象的方式把基础类型包装成对象，再调用相应类中的计算方法去完成计算。省去了我们调用基础内置数据类型自己写计算函数。

内置数据类型：byte、int、long、double 等。

包装类：Integer、Long、Byte、Double、Float、Short、BigInteger、BigDecimal

包装类比较对象中的元素要用 equals()；方法，不能用 ==（比较地址），因为能出现地址不同，元素内容相同.

**但是**在 BigDeciaml 中需要比较到元素数据的数学性质时，要注意不能使用 equals(); 要使用 compareTo(); 方法，因为元素的小数位数的不同会导致元素的内容不同，但在数学上：18.00 = 18 ，不能因为小数内容干扰是否相等的判断。



#### 装箱与拆箱：

装箱：内置数据类型被当作对象使用的时候（装箱），就可以调用方法了。

拆箱：把对象，像内置类那样，直接使用符号进行运算。



#### 不可变类：

一旦实例被创建，不可能改变其成员变量的值。

所有包装类和 String 都是不可变类。

不可变类的对象是不可改变的，因此需要拷贝该内容时可以不复制其本身，只要复制地址储存地址就可，这样提高效率优化内存，同时在多线程下不会被其他线程篡改，省掉同步锁。正因如此，给此类型的类的对象赋新值时，并不是改变对象本身而是创建新的对象，如频繁用到，会产生很多无用拉级，建议使用可代替的可变类如：String 和 StringBuffer



------

Math类：包含执行基本数字运算的方法，如基本指数，对数，平方根和三角函数。 

StrictMath类：方法同于 Math 类，解决不同平台（X86 ARM）之间浮点计算误差不相同问题,但速度不如 Math 类。



------

### 随机数

Random类：生成伪随机数。可设定生成随机数的界限以及宽度（数字的总位数）。

SecureRandom类：提供了一个密码强的随机数生成器，继承于 random 类。

**ThreadLocalRandom**：继承于 random 类 ，最主要的作用 解决 random 类中一些 方法无法设置两边边界的问题。该方法是个静态方法不能直接创建对象（单例设计模式） 但可以调用该类中 current(); 去使用该类的其他方法。



------

### 时间

Date类：分配当前的时间，或给定一个linux时间戳去分配（因为以毫秒不是秒计算，使用时别忘*1000否则会在1970年）。

DateForamt类：是一个用于日期/时间格式化子类的抽象类，它以语言无关的方式格式化和分析日期或时间。

SimpleDateFormat类：继承于 DateFormat 类，用于以区域设置敏感的方式格式化和解析日期，该类提供很多常量用于格式化 。

Calendar类：可以为在某一特定时刻和一组之间的转换的方法，提供大量关于时间的字段用于操纵该日历字段 。这是个抽象类，但他提供静态方法供使用。

GregorianCalendar类：继承Calendar类，提供了世界上大多数国家使用的标准日历系统。



------

### maven库和junit单元测试框架在企业中的用途

junit单元测试框架：又称模块测试。



------

### 字符串

String类：字符串类，提供方法操作字符串。Java程序中的所有字符串文字（例如`"abc"` ）都被实现为此类的实例。

```java
String.format - 使用指定的格式字符串和参数返回格式化的字符串。(可解决在 仅限格式化输出时 小数的位数)
```

**注意:**字符串不变; 它们的值在创建后不能被更改。 字符串缓冲区支持可变字符串。  因为String对象是不可变的，它们可以被共享。因此再使用String类时，往字符串中追加字符串，实际上是又新建一个和源对象名字相同的新对象，但旧对象还是存在的，如大量操作会损失大量的性能。

StringBuilder类：为字符串插入和追加解决上述问题，该类在多线程中无法同步，但速度快。

StringBuffer类：解决StringBuilder，线程同步问题。

```bash
# 需要说明的是，CharSequence就是字符序列(还是个接口String类实现了它)，String, StringBuilder和StringBuffer本质上都是通过字符数组实现的！

# 源码中 String 类的 equals 的方法继承于 Object 类,Object 类中的 equals 方法只对比对象的地址,String 类的 equals 的方法虽然重写但仅支持 String 类的对象去对比其内容字符串是否相同


```

 

------

### 异常

Throwable类：是Java语言中所有错误和异常的超类。

Error类：错误类，是Throwable的直接子类。

Exception类：异常类，是Throwable的直接子类。

```bash
# Error类的使用场景：  
是指程序无法处理的错误，表示应用程序运行时出现的重大错误。(很难通过完善代码修复)例如jvm运行时出现的, OutOfMemoryError以及Socket编程时出现的端口占用等程序无法处理的错误。

# Exception类的使用场景:
 * 异常可分为运行时异常跟编译异常
 * <1> 运行时异常：即RuntimeException及其之类的异常。这类异常在代码编写的时候不会被编译器所检测出来，是可以不需要被捕获，
 * 但是程序员也可以根据需要进行捕获抛出。常见的RUNTimeException有：NullPointException（空指针异常），
 * ClassCastException（类型转换异常），IndexOutOfBoundsException（数组越界异常）等。
 *
 * <2> 编译异常：RuntimeException以外的异常。这类异常在编译时编译器会提示需要捕获，如果不进行捕获则编译错误。
 * 常见编译异常有：IOException（流传输异常），SQLException（数据库操作异常）等。
 *
 * 注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。
```

RuntimeException类：继承于Exception类，各种运行时异常的超类，多出现语法没有错误（代码可编译）但运行时出错。

ReflectiveOperationException类：继承于Exception类，各种反射异常的超类（java的反射是指程序在运行期间可以拿到对象的的所有信息）。

![](E:\learnt\JAVA\异常跟错误都继承于Throwable类.png)



#### 异常处理

```java
// 异常处理两种办法：

// try catch finally -捕获异常 ->使用场景：捕获异常并个人处理彻底解决问题，其他使用者使用没问题。
try() {
    // 有异常的程序代码
} catch(异常类型 异常变量名) {
	// 调用异常方法，或根据需求要写的代码    
} finally{
    /* 
    finally 代码块无论是否捕获成功异常都会执行，即使在 catch 代码块中添加 return 关键字，并捕获异常成功也会先执行 catch 代码块中其他内容，再执行 finally 代码块的内容，最后执行 returen ，如果 finally 代码块中恰好也有return ，那 catch 里的 returen 毛用没有。
    因此，finally 代码块适合运行清理等善后代码。
    */
}

// throws throw -抛出异常并声明异常 ->使用场景：抛出异常并提示所有使用者，并让 JVM 自行解决。
public void demo() throws 异常类型，可多个{
    throw new 异常类型对象
}
```

存在多个 catch 时，注意 catch 的顺序，异常类的子类要在异常类的父类之前，以避免想要捕获的异常丢失的问题。

自己编写的类继承各种异常类，可自定义异常。

IllegalArgumentException：非法或不正确的参数异常



------

###  

### 文件	&	输入输出流(File 	&	I/O Stream)

#### 文件

文件(file) 	文件夹(folder) 	文件路径(file path) 	目录(directory)

绝对路径  (absolut path)	相对路径  (relative path)

Windows10 的文件路径的书写方式与 Linux 的不同：

- UNIX根目录的磁盘驱动器说明符"/"
- Windows UNC路径名的"\\"

File 类：文件和目录路径名的抽象表示。 并提供一些方法进行操作。



#### 输入输出流

##### 介绍

Java.io 包几乎包含了所有操作输入、输出需要的类。

I/O 流表示输入源或输出目标。一个流可以表示许多不同类型的源和目标，包括磁盘文件、设备、其他程序和内存阵列。

Input : 输入       Output: 输出

判断输入还是输出要站在操作目标的角度上。

因我们操作的目标是 Java program(程序)：

- 从一个数据源读取数据 ———— 输入流： InputStream
- 向一个目标写入数据 ———— 输出流： OutputStream

![](E:\learnt\JAVA\IOStream\Reading information into a program.gif)

读取输入(例：查阅文件)



![](E:\learnt\JAVA\IOStream\Writing information from a program.gif)

写入输出(例：保存文件)



##### 类介绍

byteStreams : 字节流
程序使用字节流来执行 8 位字节的输入和输出。

字符流在 AIP 中属于 IO 包，但不在 InputStream 和 OutputStream 抽象类中.
字符流只能使用文字类的文件。

字符流和字节流是可以互相转换的使用：InputStreamReader 和 OutputStreamWriter ,
这两个类是没有缓冲区的，建议用 Buffered 类 包装一下再去使用。

缓存区：普通字节流或字符流读取一个字符的字节编码，进行操作，将多个字符的字节编码打包成数组存入缓存，当数组存满时在一起操作。

Java 提供带缓存区的类(带Buffered)：

* 装饰设计模式：（普通套餐的升级）
* 使用装饰设计模式的类，需要有这种类的基础类。（这种类算是基础类的 VIP 版本）
* 有四个缓冲流类用于包装非缓冲流：
* BufferedInputStream并 BufferedOutputStream创建缓冲字节流，而 BufferedReader BufferedWriter 创建缓冲字符流。



![](E:\learnt\JAVA\IOStream\IOStream.png)

PrintStream：装饰类一种负责格式化输出，构造可传入输出流，以及文件名字(并可以指定字符集)，该类中的方法不会抛出I / O异常。

PrintWriter：PrintStream 类的“字符流”版本，当然对字符的输出格式更多。

#### **注意：输出时如果不是追加内容将会覆盖源文件。**

------



### JAVA 的多线程

多线程编程：当一个程序中多个线程对同一个共享的资源，进行抢占并操作。

- 多线程模型是 JAVA 最基础的并发模型。
- 读写网络数据，数据库，Web开发,都要依赖 JAVA 多线程模型



#### 并发与并行

##### 并发 Concurrency

可以在同一段时间内做不同的事情，**不同任务交替工作。**

##### 并行 Parallelism

可以在同一时刻做不同的事情，**不同任务同时工作。**



#### 进程与线程 

**线程存在于进程中，一个进程中必须要有一个线程。**

##### 进程  Process

- 一个进程有一个独立的执行环境。
- 一个进程通常有一套完整的、私有的基本运行时资源；特别是，每个进程都有自己的内存空间；因而使得多进程之间的通讯效率低于多线程。
- 进程通常被视为程序或应用程序的同义词。然而，用户所看到的单个应用程序实际上可能是一组协作进程。
- JVM 的大多数实现都作为单个进程运行。Java 应用程序可以使用 ProcessBuilder对象创建其他进程。
- 多进程应用程序，是健硕的在安全情况下，一个进程的崩溃不会导致整个应用或其他进程崩溃。



##### 线程 Thread

* 线程有时被称为轻量级进程。进程和线程都提供了一个执行环境，但是创建一个新线程比创建一个新进程需要更少的资源。
* 线程存在于进程中每个进程至少有一个。线程共享进程的资源，包括内存和打开的文件。这有助于高效但可能存在问题的沟通。
* 一个 JAVA 程序实际上是一个 JVM 的进程，JVM 的进程中又有一个主线程来执行，这个就是我们 main 方法。
* 在主线程中我们可启动多个子线程，就可以执行多个任务。
* 当然 JVM 进程除了主线程外还有一些工作线程(又称用户线程(就是是你自己写的线程这又相当于主线程的子线程))为进程服务，主线程停掉不会影响子线程工作。



##### 线程的调度

- 线程的调度，是由操作系统系统决定的，JVM 也是操作系统中的进程之一。
- 因此在 JAVA 中使用代码调整优先级(priority)并不一定能使高优先级的线程先的任务先执行。
- 尤其是在低任务或高性能处理器面前，确实是设置高优先级，但处理速度太快，就像没设置一样。
- 综上，如果有优先级调度的需求建议使用线程通信(线程之间：唤醒与等待与插队)，而别以来优先级调度。



##### 扩展：

一个应用程序，在进程和线程中可有多种搭配实现：

- 多进程模式（多个进程每个进程只有一个线程）
- 多线程模式（一个进程但里面有多个线程）
- 多进程加多线程组合



#### JAVA 中创建线程

##### 要用到类和接口介绍

java.lang 包下的 Thread 类，该类继承于 Object 实现  Runnable 接口

- Thread 类负责提供控制线程的方法和变量。
- Runnable 接口负责提供一个名为 run() 的抽象方法，用于该接口被实现后写入线程要执行的内容。
- Thread 类中提供了传入 实现了 Runnable 接口的类的构造

简单控制线程的方法(Thread Api中的一些方法)：

- start() 方法打开线程 (不要 run() 方法，那只是单纯调用方法)
- sleep(long millis) 方法暂停线程执行绪设定暂停时间 
- setPriority(int newPriority) 更改此线程的优先级。 JVM 1~10 等级默认5。除了1~10常量还有字符定义的三个常量，分别为：MAX_PRIORITY = 10，MIN_PRIORITY = 1，NORM_PRIORITY = 5。main 线程为5。



##### 创建方法

根据 Runnable 接口 和 Thread 类的关系得出：

- 当线程内容不需要继承其他类的时候可以让写线程内容的类直接继承 Thread  类并复写 run() ，使用时直接实例我们自己写类，并调用 Thrad 类 的方法即可。
- 当线程内容需要继承其他类的时候，由于 JAVA 单继承的特性，写线程内容的类不能继承 Thread 了，就先实现 Runnable 接口 ，把线程的执行内容写完。在使用时实例 Tread类，并在其对象内传入，写线程内容的类的对象。

```java
Thread thread = new Thread(new MyThread);
thread.start();
```



#### Daemon Thread守护线程

守护线程是一个奇特的线程，他为主线程以及子线程服务，在主线程或子线程结束后，自动结束，并与主线程一起销毁。

- 守护线程当进程不存在或主线程停止，守护线程也会被停止。
- 当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程
- 例：gc线程 （线程不定时回收垃圾）属于守护线程。
- 在守护线程中产生的新线程也是守护线程。
-  不要认为所有的应用都可以分配给守护线程来进行服务，比如读写操作或者计算逻辑。



可以自己创建守护线程

- 名字要易识别
- 调用 Thread 类中的 setDeamon(true) 方法 
- **注意：**必须在调用线程的 start() 方法之前设置，否则会抛出IllegalThreadStateException异常。
- isDaemon() 方法可测试该线程是否是守护线程， 返回 bollean 值。





#### 线程的执行状态

##### 自然状态

 多线程的执行顺序**在没有控制需求的情况下**就像地铁上的乘客一样，主线程(main)是地铁，子线程时乘客。

- 当在主线程中开启子线程时，子线程开始执行，与此同时主线线程也会同步执行，直到各自执行完各自的内容，或出现突发情况终止。
- 就像这趟地铁(主线程)只会沿着既定线路行驶，但车上的乘车(开启的子线程)会去往自己需要地方，因此地铁和乘客都在同时执行自己的事情。

##### 实际状态

但为了满足实际需要我们肯定需要控制线程，当我们控制线程时，这些线程会有不同的状态：

1. New ：新创建的线程，还没有开始执行
2. Runnable：正在执行的线程，执行 run(); 方法中的 JAVA 代码
3. Blocked：正在执行的线程，但因需同步共同的变量信息或其他操作，所阻塞而被挂起
4. Waiting：正在执行的线程，但因要配合其他线程的执行，完成线程的通信而等待中，只能被唤醒。
5. Timed Waiting：和 Waiting 状态类似但，该状态是通过计时等待，计时结束自动唤醒。
6. Terminated：线程终止，线程执行结束或出现异常被迫结束

线程的执行可在在上述 2 3 4 5 这几个状态中进行切换以满足线程之间通信来实现用户的具体需求。

实现以上状态需要用到 Api 来自不同的类，下面分状态介绍。



#### 同步 锁 Block

##### 共享与抢占带来的问题

线程主要通过 对字段和 对象引用字段 的共享访问来进行通信。这种通信形式非常高效，但线程运作是抢占式的，会导致两种错误：线程干扰和内存一致性错误。

- 线程干扰反例：当一些严格操作的业务场景时，不同的的执行功能会出现干扰，例如账户中0元，线程A：存入500，线程B：取出200，B线程抢占到了取出200，0元账户取出200 能 ？
- 内存一致性反例：网上抢鞋子就剩最后一双，A线程去抢，B线程也去抢，A先抢到，内存不一致B也能抢到？

因此我们需要一把“锁”，规范线程的执行不受干扰，同步线程内存使其一致。



##### 锁是否公平

Java 中的锁总共可分为两类：公平锁和非公平锁。

- **公平锁：**每个线程获取锁的顺序是按照线程访问锁的先后顺序获取的，最前面的线程总是最先获取到锁。
- **非公平锁：**每个线程获取锁的顺序是随机的，并不会遵循先来先得的规则，所有线程会竞争获取锁。
- **举个例子：**公平锁就像开车经过收费站一样，所有的车都会排队等待通过，先来的车先通过，



##### 使用同步锁所需的类与方法

###### synchronized  同步锁

- 写代码时发现 synchronized 是关键字，他基于 JVM 层面（随着版本更迭可能性能会变强）。
- 使用时需要新建并传入 Object 对象或变量。(相当于一个判断机制)
- 同步代码块：线程 run() 方法中需要上锁的内容。
- 同步方法：synchronized 修饰的方法
- 非公平锁

```java
public class ThradA implements Runnable {
    Object lock = new Object();
	@override
	run(){
		synchronized(lock){
 			// 上锁内容       
    	}
	}
}  
```



###### 同步语句

- ReentrantLock 类中的方法完成同步,还有关于锁设置以及查验等操作的方法。
- lock() 方法上锁， unlock() 方法解锁，千万别忘了解锁，否则会出现死锁的情况。
- 死锁是一种持久型的状态。多个线程同时被阻塞,它们中的一个或者全部都在等待某个资源被释放。程序和线程都处于等待状态。
- 默认构造非公平锁。
- ReentrantLock(boolean fair) 该构造可创建公平锁。
- 该类实现于 Lock  和 Serializable 接口。

```java
public class ThradB implements Runnable {
    // 创建一个公平锁
	ReentrantLock reentrantLock = new ReentrantLock (ture);
	@override
	run(){
         // 上锁
        try{
            reentrantLock.lock();
            // 上锁内容
        }catch (Exception e){
            e.printStackTrace();
            System.out.println(Thread.currentThrad().getName() + "线程上锁出现异常！");
        }finally{
            // 解锁
            try{
                reentrantLock.unlock();
            }catch (Exception e){
                e.printStackTrace();
                System.out.println(Thread.currentThread().getName() + "线程开锁出现异常");
            }
        }
	}
}  
```



#### 线程的通信

##### 同一类型多线程之间通信（线程调度）

可使用 Thread 类中的方法进行通信

###### join

```java
/* 线程插队（属于线程调度）
 * join()
 * join(long millis)
 * join(long millis, int nanos)
 * 调用该方法后，后面还未执行的代码（子线程调用等），都必须等，
 * 等到使用 join() 方法的线程执行完毕才能继续执行。
 * join() 方法中的参数，是使用 join() 方法的线程执行的时间限制，
 * 超过设置的时间限制，直接执行后面的代码。（这种方法叫 超时等待 或 即使等待）
 * millis - 以毫秒为单位等待的时间
 * nanos - 0-999999等待的额外纳秒
 * 换算进率为1000
 * 1 毫秒 = 1000000 纳秒
 * 1 秒 = 1000 毫秒
 * 1 毫秒 = 1000 微秒
 * 1 微秒 = 1000 纳秒
 */
```



###### sleep

```java
/* 静态方法：线程休眠 （属于线程调度）
 * sleep(long millis)
 * sleep(long millis, int nanos)
 * 导致正在执行的线程以指定的毫秒数加上指定的纳秒数来暂停（临时停止执行），
 * 这取决于系统定时器和调度器的精度和准确性。 线程不会丢失任何显示器的所有权。
 * 该方法需要抛出异常，并需要 Try Catch 包裹。
 */
```



###### yield

```java
/* 静态方法：线程让步 （属于线程调度）
 *  yield() 对调度程序的一个暗示，即当前线程愿意产生当前使用的处理器。
 * 它让掉当前线程 CPU 的时间片，使正在运行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。
 * 它可能会获取到，也有可能被其他线程获取到。
 * 因此无法保证yield()真的能达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。
 */
```



##### 不同类型线程之间的通信(等待唤醒机制)

可使用 Object 类中的方法

###### wait

```java
/*
* void wait()
* 导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法。
* void wait(long timeout)
* 导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法，或指定的时间已过。
* void wait(long timeout, int nanos)
* 导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法，或者某些其他线程中断当前线程，
* 或者已经过了一定量的实时时间。
* 使用该方法有异常：
* IllegalMonitorStateException - 如果当前线程不是对象监视器的所有者。
* InterruptedException - 如果任何线程在当前线程等待通知之前或当前线程中断当前线程。
* 当抛出此异常时，当前线程的中断状态将被清除。
*/
```



###### notify notifyAll

```java
    /*
     * void notify()
     * 唤醒正在等待对象监视器的单个线程。 如果任何线程正在等待这个对象，其中一个被选择被唤醒。
     * 选择是任意的，并且由实施的判断发生。 线程通过调用wait方法之一等待对象的监视器。
     *
     * 唤醒的线程将无法继续，直到当前线程放弃此对象上的锁定为止。
     * 唤醒的线程将以通常的方式与任何其他线程竞争，这些线程可能正在积极地竞争在该对象上进行同步;
     * 例如，唤醒的线程在下一个锁定该对象的线程中没有可靠的权限或缺点。
     *
     * 该方法只能由作为该对象监视器的所有者的线程调用。 线程以三种方式之一成为对象监视器的所有者：
     * 通过执行该对象的同步实例方法。
     * 通过执行在对象上同步的synchronized语句的主体。
     * 对于类型为Class,的对象，通过执行该类的同步静态方法。
     * 一次只能有一个线程可以拥有一个对象的显示器。
     *
     * notifyAll()
     * 唤醒正在等待对象监视器的所有线程。 线程通过调用其中一个wait方法等待对象的监视器。
     *
     */
```



------



### 集合框架
